#+TITLE: How to Read Programs
#+AUTHOR: Charles Ellis <hamled@hamled.dev>

* Preface
How to Read Programs is a book about learning the art of coding. There are many books about coding which have been highly successful in guiding many people, myself included, to an understanding of writing computer code and software development generally. In fact, the title of this book is a play on [[https://htdp.org/][just such a book]], one which I recommend to anyone looking for a more traditional approach that goes beyond this text in many ways.

This book seeks to be an alternative to that traditional approach. By focusing foremost on the skills associated with reading code, this book aims to make accessible a mode of interacting with programs that many people can benefit from in their work and projects. Everyone receiving an existing piece of code, whether it be a spreadsheet, a website, a macro in an automation toolkit, or anything else is likely to have need at some point to be able to understand portions of that code and make small modifications. Further, some tasks often associated with software security jobs include reading code, often complex and intentionally obfuscated code, as a major component.

Of course, by learning how to read code we will also learn something about how to write code. When software developers write computer code they also necessarily will be reading some code -- whether their own as they write, or existing code that they're changing. But in the same way an experienced programmer does not inherently have the skills necessary to read and understand the "machine code" that is produced by their compiler, the extent to which this book teaches how to write code will be limited compared to texts that focus on that set of skills.

Fundamental software development concepts will be introduced because they are visible in the structure and patterns of the code when it is read. A discussion of the pros and cons and proper usage of these concepts in the design and development of programs is out of scope for this book, however. Instead we will learn how to recognize the existence of concepts in the code (whether the original source, or a derivative such as a compilation output), and leverage that to better understand the intent and thought process of the program's creators.

The ultimate goal of reading a program is to absorb knowledge of how that program behaves under various conditions. Usually these conditions are known as the "inputs" to the program, but we will see that there are additional elements that impact behavior and are categorized in other ways. For any sizable program, likely including every program that you've interacted with on a computer in your normal activities, its not feasible for a person to absorb complete knowledge of that program's behavior down to the level of every single command in the program's code.

There are often tens of millions of such commands in a single program, which mirrors the reality for software developers that most of their creations are millions of lines of "source code" when all of the associated libraries are included. And we will address this issue in a similar manner to the software development profession, by operating at different levels of abstraction within the same piece of code. We might label a section of the code that contains ultimately thousands of commands, calling it by a name that represents their overall intent (e.g. "send email to an address" or "delete a file"). Indeed, software developers use these "identifiers" constantly when building code.

As we will see later, it is important to keep in mind that these labels often reflect our understanding of the intent of the programmer, but with a direct review of the actual commands we can gain additional knowledge beyond what even the original developer had. This additional knowledge can represent a deviation from the intended behavior, in which case it is generally labeled as a bug. Such bugs can be valuable if they have significant impact on whether the program can be made to violate its security rules, and a number of jobs within the software security industry are concerned primarily or in part with discovering these bugs. While a comprehensive discussion of security code reviews is beyond the scope of this book, the skills taught here will aid in performing such reviews. For a much more in-depth treatment of the subject, please consider [[https://www.pearson.com/us/higher-education/program/Dowd-Art-of-Software-Security-Assessment-The-Identifying-and-Preventing-Software-Vulnerabilities/PGM306255.html][The Art of Software Security Assessment]].

* What are Programs?
If we're going to learn the art of coding by practicing how to read programs, we should first have a clear understanding of what it means to read a program. I'm going to make the assumption that you are already familiar with what it means to read something, as you're most likely doing that right now. So then what is a program, and how can it be read? Programs, like many terms in computing, is used in a variety of ways both vague and specific. For our purposes, we will use one of the more vague definitions for "program": an individual software project that runs on a computer system, with its associated code and data. Some programs are designed to present a user interface and receive interactive inputs from human users, such as a web browser or a messaging application. Other programs are primarily designed to interact only with other software, such as a database running on a server in a datacenter.

So if your messaging application is a program, how could we read it? Before we can begin to understand that it is necessary to have a deeper understanding of the program than is warranted when operating it as a user. In particular, we need to talk about what programs /are made of/. I alluded to it in the previous paragraph, but programs consist of two kinds of stuff: code and data.
